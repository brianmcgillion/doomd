;;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

* Interface Tweaks
:PROPERTIES:
:ID:       7d3f0a7b-101c-44cd-920c-65a82bc21877
:END:
#+BEGIN_SRC emacs-lisp
;;;
;;;
;;; BEGIN_Interface_Tweaks
;;;
;;;

;; When starting a new frame make it maximized
(add-to-list 'initial-frame-alist '(fullscreen . fullboth))
(push '(fullscreen . fullboth)   default-frame-alist)

;; Set your own banner to replace the default doom one "convert image.png
;; -resize 600 -quality 75 OUTPUT.png" try resize 400 for smaller resolutions
;; e.g. 1080p
(setq! fancy-splash-image (concat doom-private-dir "banner/trancendent-gnu.png"))

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string.

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq! doom-theme 'doom-dracula)

;; Font configuration with fallbacks
;; Primary fonts: FiraCode Nerd Font, Fira Sans, Source Serif 4, Font Awesome
;; Fallbacks ensure graceful degradation if fonts are missing
(setq! doom-font (font-spec :family "FiraCode Nerd Font Mono" :size 13)
       doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13)
       doom-big-font (font-spec :family "FiraCode Nerd Font Mono" :size 19)
       doom-serif-font (font-spec :family "Source Serif 4" :size 13)
       doom-symbol-font (font-spec :family "Font Awesome 7 Free" :size 13))

;; Verify fonts exist and set fallbacks if needed
(defun bmg/font-available-p (font-family)
  "Check if FONT-FAMILY is available on the system."
  (member font-family (font-family-list)))

(defun bmg/set-font-with-fallback (font-var primary &rest fallbacks)
  "Set FONT-VAR to PRIMARY font, or first available FALLBACK."
  (let ((available (or (and (bmg/font-available-p (plist-get primary :family)) primary)
                       (cl-find-if (lambda (f) (bmg/font-available-p (plist-get f :family)))
                                   fallbacks))))
    (when available
      (set font-var available))))

;; Apply font fallbacks after frame creation (fonts not available before)
(add-hook! 'after-init-hook
  (defun bmg/apply-font-fallbacks ()
    (bmg/set-font-with-fallback 'doom-font
                                (font-spec :family "FiraCode Nerd Font Mono" :size 13)
                                (font-spec :family "Fira Code" :size 13)
                                (font-spec :family "JetBrains Mono" :size 13)
                                (font-spec :family "Hack" :size 13)
                                (font-spec :family "monospace" :size 13))
    (bmg/set-font-with-fallback 'doom-variable-pitch-font
                                (font-spec :family "Fira Sans" :size 13)
                                (font-spec :family "Cantarell" :size 13)
                                (font-spec :family "DejaVu Sans" :size 13)
                                (font-spec :family "sans-serif" :size 13))
    (bmg/set-font-with-fallback 'doom-serif-font
                                (font-spec :family "Source Serif 4" :size 13)
                                (font-spec :family "Source Serif Pro" :size 13)
                                (font-spec :family "DejaVu Serif" :size 13)
                                (font-spec :family "serif" :size 13))
    (bmg/set-font-with-fallback 'doom-symbol-font
                                (font-spec :family "Font Awesome 7 Free" :size 13)
                                (font-spec :family "Font Awesome 6 Free" :size 13)
                                (font-spec :family "Symbols Nerd Font" :size 13)
                                (font-spec :family "Noto Color Emoji" :size 13))))

(with-eval-after-load 'doom-themes
  (setq! doom-themes-enable-bold t
         doom-themes-enable-italic t))

;; Fix gnus face inheritance cycle - must run early before gnus loads
;; The cycle is: gnus-group-news-low-empty inherits from gnus-group-news-low
;; which inherits from gnus-group-news-low-empty
;; Use with-eval-after-load for gnus to set faces only when gnus is actually loaded
(with-eval-after-load 'gnus
  (set-face-attribute 'gnus-group-news-low nil
                      :weight 'normal
                      :foreground "#565761")  ; doom-dracula base5
  (set-face-attribute 'gnus-group-news-low-empty nil
                      :weight 'normal
                      :foreground "#3d3f4c")) ; doom-dracula base4

(with-eval-after-load 'org-modern
  (set-face-attribute 'org-modern-symbol nil :family "Font Awesome 7 Free")
  (set-face-attribute 'org-modern-label nil :height 1.0)
  (set-face-attribute 'org-modern-block-name nil :height 1.0))

;; be as colorful as possible.
(setq treesit-font-lock-level 4)

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq! display-line-numbers-type t)

;; Blinking cursors are annoying
(blink-cursor-mode -1)

(setq! +doom-dashboard-menu-sections
       '(("Open org-agenda"
          :icon (nerd-icons-octicon "nf-oct-calendar" :face 'doom-dashboard-menu-title)
          :action bmg/switch-to-agenda)
         ("Recently opened files"
          :icon (nerd-icons-faicon "nf-fa-file_text" :face 'doom-dashboard-menu-title)
          :action recentf-open-files)
         ("Reload last session"
          :icon (nerd-icons-octicon "nf-oct-history" :face 'doom-dashboard-menu-title)
          :when (cond ((modulep! :ui workspaces)
                       (file-exists-p (expand-file-name persp-auto-save-fname persp-save-dir)))
                      ((require 'desktop nil t)
                       (file-exists-p (desktop-full-file-name))))
          :action doom/quickload-session)
         ("Open project"
          :icon (nerd-icons-octicon "nf-oct-briefcase" :face 'doom-dashboard-menu-title)
          :action projectile-switch-project)
         ("Open private configuration"
          :icon (nerd-icons-octicon "nf-oct-tools" :face 'doom-dashboard-menu-title)
          :when (file-directory-p doom-private-dir)
          :action doom/open-private-config)
         ("Open documentation"
          :icon (nerd-icons-octicon "nf-oct-book" :face 'doom-dashboard-menu-title)
          :action doom/help)
         ("RSS"
          :icon (nerd-icons-octicon "nf-oct-rss" :face 'doom-dashboard-menu-title)
          :action =rss)
         ))
;;;
;;;
;;; END_Interface_Tweaks
;;;
;;;

#+END_SRC

* General
:PROPERTIES:
:ID:       5fa6e40a-6235-4da7-9c35-3df39775a7af
:END:

#+BEGIN_SRC emacs-lisp
;;;
;;;
;;; BEGIN_General
;;;
;;;

;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq! user-full-name "Brian McGillion"
       user-mail-address "brian@ssrc.tii.ae"
       ;; Who remembers all the commands :)
       which-key-idle-delay 0.5
       ;; Prefer encrypted auth source
       auth-sources '("~/.authinfo.gpg" "~/.netrc")
       ;; M-x projectile-discover-projects-in-directory
       ;; M-x projectile-discover-projects-in-search-path
       projectile-project-search-path '(("~/.dotfiles" . 1)("~/projects" . 6)("~/.config" . 2)("~/Documents/org" . 2))
       projectile-auto-discover nil)

;; Enable word-wrap for text modes (visual-line-mode wraps at window edge)
;; Using text-mode-hook covers org-mode, markdown-mode, and other text modes
(add-hook 'text-mode-hook #'visual-line-mode)

;; If a file changes on disk update the buffer to match
(global-auto-revert-mode t)

(dirvish-side-follow-mode t)

;; Use a custom dictionary
(setq! ispell-dictionary (if IS-MAC "en_GB" "en_US"))

;; NixOS doesn't have /usr/share/dict/words, disable word-list completion in text-mode
;; (aspell handles spell-checking, this only affects M-TAB word completion)
(setq! text-mode-ispell-word-completion nil)

(set-language-environment-charset "UTF-8")

;; Use the Languagetool only in server mode
(setq! langtool-http-server-host "localhost"
       langtool-http-server-port 8081
       langtool-default-language nil)

(with-eval-after-load 'license-snippets
  (license-snippets-init))

;; load all the elfeed configurations
(load! "elfeed-config.el")

;; misc selection of useful functions
(use-package crux
  :defer t)

;; Clone git repos or jump to the project in the code path
;; https://github.com/NinjaTrappeur/my-repo-pins
(use-package my-repo-pins
  :commands (my-repo-pins)
  :init
  (setq my-repo-pins-code-root "~/projects/code"))

(use-package inheritenv
  :config
  ;; ensure that the environment is carried over to the subshell that is called.
  ;; this was tested against go-mode specifically go-import-add
  (inheritenv-add-advice #'process-lines)
  (inheritenv-add-advice #'shell-command-to-string))

(with-eval-after-load 'consult
  ;; Needed to ensure that preview is working live, without the need to
  ;; C-SPC everytime you need to see a preview. see vertico/config.el
  ;; where we are overriding the override :)
  (consult-customize
   +default/search-project +default/search-other-project
   +default/search-project-for-symbol-at-point
   +default/search-cwd +default/search-other-cwd
   +default/search-notes-for-symbol-at-point
   +default/search-emacsd
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file
   consult--source-recent-file consult--source-project-recent-file consult--source-bookmark
   :preview-key (list "C-SPC" :debounce 0.1 'any)))


;; Try to stop killing emacs with C-x C-c and use C-c q f
;; when using the daemon mode.
(defun my-confirm-kill-daemon (prompt)
  "Ask whether to kill daemon Emacs with PROMPT.
Intended as a predicate for `confirm-kill-emacs'."
  (or (not (daemonp))
      (yes-or-no-p prompt)))

(setq! confirm-kill-emacs #'my-confirm-kill-daemon)

;;;###autoload
(defun bmg/api-key-from-auth-source (&optional host user)
  "Lookup api key in the auth source.
By default, the LLM host for the active backend is used as HOST,
and \"apikey\" as USER."
  (if-let ((secret
            (plist-get
             (car (auth-source-search
                   :host (or host)
                   :user (or user "apikey")
                   :require '(:secret)))
             :secret)))
      (if (functionp secret)
          (encode-coding-string (funcall secret) 'utf-8)
        secret)
    (user-error "No API key found for host: %s, user: %s. Check your auth-source file."
                (or host "default") (or user "apikey"))))

;;;
;;;
;;; END_General
;;;
;;;
#+END_SRC

* Code
:PROPERTIES:
:ID:       4460f37d-9944-4717-acf5-e2ab1e410787
:END:
#+BEGIN_SRC emacs-lisp
;;;
;;;
;;; BEGIN_code
;;;
;;;

;; Add handlers for SELinux files and MDX (React/JSX markdown)
(add-to-list 'auto-mode-alist '("\\.te\\'" . m4-mode))
(add-to-list 'auto-mode-alist '("\\.mdx\\'" . gfm-mode)) ;; GitHub Flavored Markdown

;; make a shell script executable automatically on save
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

(setq c-default-style "linux") ;; set style to "linux"

;;setup clangd lsp
(with-eval-after-load 'lsp-clangd
  (setq lsp-clients-clangd-args
        '("-j=3"
          "--background-index"
          "--clang-tidy"
          "--completion-style=detailed"
          "--header-insertion=never"
          "--header-insertion-decorators=0"))
  (set-lsp-priority! 'clangd 2))

;; use just mode for setting tasks to run at the cmdline
(use-package justl
  :config
  (map! :map justl-mode-map "e" 'justl-exec-recipe))

;; Use a variable for the dotfiles path to avoid hardcoding
(defvar bmg/dotfiles-path (expand-file-name "~/.dotfiles")
  "Path to dotfiles repository for Nix flake expressions.")

(with-eval-after-load 'lsp-mode
  (setq lsp-nix-nixd-server-path "nixd"
        lsp-nix-nixd-formatting-command ["nixfmt"]
        lsp-nix-nixd-nixpkgs-expr (format "import (builtins.getFlake \"%s\").inputs.nixpkgs { }" bmg/dotfiles-path)
        lsp-nix-nixd-nixos-options-expr (format "(builtins.getFlake \"%s\").nixosConfigurations.arcadia.options" bmg/dotfiles-path)))
;; Note: home-manager options commented out - home-manager appears to be integrated as a NixOS module
;; If you have standalone home-manager configs, use:
;; lsp-nix-nixd-home-manager-options-expr (format "(builtins.getFlake \"%s\").homeConfigurations.\"user@host\".options" bmg/dotfiles-path)


;;;
;;;
;;; END_code
;;;
;;;
#+END_SRC

* LLM/ML
#+begin_src emacs-lisp
;;;
;;;
;;; BEGIN_llm
;;;
;;;

;; Inline code completions via GitHub Copilot
;; Primary LLM interaction is via GitHub Copilot CLI (external)
;; Doom's :tools llm module provides gptel-magit for commit messages
(use-package copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word))
  :config
  (setq! copilot-indent-offset-warning-disable t))

;; Configure gptel with GitHub Copilot as the backend
;; Uses existing GitHub Copilot subscription - no separate API key needed
;; Authentication handled automatically via GitHub login
(with-eval-after-load 'gptel
  (setq! gptel-model 'claude-opus-4.5
         gptel-backend (gptel-make-gh-copilot "Copilot")))

;;; AI-Powered Knowledge Management Functions

(defgroup bmg/llm nil
  "Configuration for LLM-powered knowledge management."
  :group 'tools
  :prefix "bmg/llm-")

(defcustom bmg/llm-context-small 4000
  "Small context window size for quick LLM operations (e.g., tag suggestions)."
  :type 'integer
  :group 'bmg/llm)

(defcustom bmg/llm-context-medium 8000
  "Medium context window size for detailed LLM operations (e.g., summaries)."
  :type 'integer
  :group 'bmg/llm)

(defcustom bmg/llm-context-tiny 2000
  "Tiny context window size for minimal LLM operations."
  :type 'integer
  :group 'bmg/llm)

(defun bmg/suggest-tags-for-buffer ()
  "Use LLM to suggest filetags for current org-roam buffer.
Copies suggested tags to kill ring for easy insertion.
Bound to SPC z S."
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (user-error "Not in an org buffer"))
  (let ((content (buffer-substring-no-properties (point-min) (min (point-max) bmg/llm-context-small))))
    (when (string-empty-p (string-trim content))
      (user-error "Buffer is empty, nothing to analyze"))
    (message "Requesting tag suggestions...")
    (condition-case err
        (gptel-request content
          :system "Suggest org-mode filetags for this note. Return ONLY a single line in colon-separated format like :paper:security:tpm: with no explanation.
Focus on these categories:
- Document types: paper, website, book, meeting, project, reference
- Security domains: security, tpm, tee, sgx, trustzone, confidential_computing, attestation, secure_boot
- Attack types: exploit, side_channel, vulnerability, fuzzing
- Systems: virtualization, containers, android, linux, firmware, hardware
- Topics: cryptography, ml, networking, performance, architecture
Keep to 3-6 most relevant tags."
          :callback (lambda (response info)
                      (if (not response)
                          (message "Tag suggestion failed: %s" (plist-get info :status))
                        (let ((tags (string-trim response)))
                          (if (string-empty-p tags)
                              (message "LLM returned empty response")
                            (kill-new tags)
                            (message "Suggested tags: %s (copied to kill ring)" tags))))))
      (error (message "Tag suggestion error: %s" (error-message-string err))))))

(defun bmg/summarize-paper ()
  "Generate AI summary for current paper note and insert at end of buffer.
Bound to SPC z s."
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (user-error "Not in an org buffer"))
  (let ((content (buffer-substring-no-properties (point-min) (min (point-max) bmg/llm-context-medium))))
    (when (string-empty-p (string-trim content))
      (user-error "Buffer is empty, nothing to summarize"))
    (message "Generating summary...")
    (condition-case err
        (gptel-request content
          :system "Summarize this academic paper or research note. Provide:

1. **One-paragraph summary** - The key contribution and findings
2. **Key contributions** (3-5 bullet points)
3. **Methodology** - How they achieved their results
4. **Relevance** - How this connects to security/systems research
5. **Potential connections** - Related areas or follow-up questions

Use org-mode formatting with ** for headings."
          :callback (lambda (response info)
                      (if (not response)
                          (message "Summarization failed: %s" (plist-get info :status))
                        (if (string-empty-p (string-trim response))
                            (message "LLM returned empty summary")
                          (save-excursion
                            (goto-char (point-max))
                            (insert "\n\n* AI Summary\n:PROPERTIES:\n:GENERATED: "
                                    (format-time-string "[%Y-%m-%d %a %H:%M]")
                                    "\n:END:\n\n" response))
                          (message "Summary inserted at end of buffer")))))
      (error (message "Summarization error: %s" (error-message-string err))))))

(defun bmg/process-inbox-item ()
  "Get AI suggestions for processing current GTD inbox item.
Run on a heading tagged :REFILE: for processing guidance.
Bound to localleader P in org-mode."
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (user-error "Not in an org buffer"))
  (let ((content (save-excursion
                   (org-narrow-to-subtree)
                   (prog1 (buffer-substring-no-properties (point-min) (point-max))
                     (widen)))))
    (gptel-request content
      :system "You are a GTD (Getting Things Done) assistant. Analyze this inbox item and suggest:

1. **Actionable?** - Is this actionable or reference material?
2. **Next action** - If actionable, what's the specific next physical action?
3. **Project** - Suggested project category:
   - @Project (code/engineering work)
   - @Research (academic/investigation)
   - @Reading (papers, books, articles)
   - @Training (learning, courses)
   - @Someday (future/maybe items)
4. **Tags** - 2-3 relevant org-mode tags in :tag1:tag2: format
5. **Org-roam?** - Should this become a permanent note in the knowledge base?
6. **Priority** - Suggested priority (A/B/C)

Be concise and actionable."
      :callback (lambda (response info)
                  (if (not response)
                      (message "Processing failed: %s" (plist-get info :status))
                    (with-current-buffer (get-buffer-create "*Inbox Processing*")
                      (erase-buffer)
                      (insert "* Processing Suggestion\n\n" response)
                      (org-mode)
                      (goto-char (point-min))
                      (pop-to-buffer (current-buffer))))))))

(defun bmg/ask-knowledge-base (question)
  "Ask a question answered from your org-roam notes (RAG).
Searches notes, retrieves relevant content, and uses LLM to answer.
Bound to SPC s Q."
  (interactive "sQuestion: ")
  (when (string-empty-p (string-trim question))
    (user-error "Please provide a question"))
  (require 'consult-org-roam)
  (message "Searching knowledge base...")
  (condition-case err
      (let* ((search-results (consult-org-roam-search--candidates question))
             (top-files (seq-take (mapcar #'car search-results) 5))
             (context ""))
        (if (null top-files)
            (message "No relevant notes found for: %s" question)
          ;; Build context from top matching files
          (dolist (file top-files)
            (when (and file (file-exists-p file))
              (condition-case nil
                  (with-temp-buffer
                    (insert-file-contents file nil 0 bmg/llm-context-small)
                    (setq context (concat context
                                          "\n\n--- " (file-name-nondirectory file) " ---\n"
                                          (buffer-string))))
                (error nil))))  ; Skip files that can't be read
          (if (string-empty-p context)
              (message "Could not read any matching files for: %s" question)
            (gptel-request (format "Context from knowledge base:\n%s\n\n---\n\nQuestion: %s" context question)
              :system "You are a research assistant with access to the user's personal knowledge base.
Answer the question based ONLY on the provided context from their notes.
- Cite which notes/files support your answer
- Quote relevant passages when helpful
- If the context doesn't contain relevant information, say so clearly
- Be concise but thorough
- Use org-mode formatting"
              :callback (lambda (response info)
                          (if (not response)
                              (message "Query failed: %s" (plist-get info :status))
                            (with-current-buffer (get-buffer-create "*KB Answer*")
                              (erase-buffer)
                              (insert "* Answer to: " question "\n\n" response
                                      "\n\n* Sources\n")
                              (dolist (f top-files)
                                (when f
                                  (insert (format "- [[file:%s][%s]]\n" f (file-name-nondirectory f)))))
                              (org-mode)
                              (goto-char (point-min))
                              (pop-to-buffer (current-buffer)))))))))
    (error (message "Knowledge base search error: %s" (error-message-string err)))))

(defun bmg/find-related-notes ()
  "Use AI to find semantically related notes to current buffer.
Analyzes current note and suggests related notes from org-roam.
Bound to SPC z R."
  (interactive)
  (require 'org-roam)
  (condition-case err
      (let* ((node-at-point (org-roam-node-at-point))
             (current-title (or (and node-at-point (org-roam-node-title node-at-point))
                                (org-get-title)
                                (buffer-name)))
             (current-tags (if node-at-point
                               (org-roam-node-tags node-at-point)
                             '()))
             (current-content (buffer-substring-no-properties
                               (point-min)
                               (min (point-max) bmg/llm-context-tiny)))
             ;; Get sample of nodes from database
             (all-nodes (org-roam-node-list))
             (sample-nodes (seq-take all-nodes 100)))
        (unless all-nodes
          (user-error "No org-roam nodes found. Is org-roam database initialized?"))
        (when (string-empty-p (string-trim current-content))
          (user-error "Buffer is empty, nothing to analyze"))
        (let ((node-list (mapcar (lambda (n)
                                   (format "- %s [tags: %s]"
                                           (org-roam-node-title n)
                                           (string-join (or (org-roam-node-tags n) '()) ", ")))
                                 sample-nodes)))
          (message "Finding related notes among %d nodes..." (length all-nodes))
          (gptel-request (format "Current note: %s
Tags: %s

Content excerpt:
%s

---

Notes in knowledge base:
%s

---

Which 5-10 notes are most likely related to the current note? Consider:
1. Topic similarity
2. Shared concepts or terminology
3. Research connections (same authors, citations, domains)
4. Potential for linking

For each suggested note, briefly explain WHY it might be related."
                                 current-title
                                 (string-join current-tags ", ")
                                 current-content
                                 (string-join node-list "\n"))
            :system "You are a knowledge management assistant helping discover connections in a Zettelkasten.
Identify notes that are semantically or conceptually related, even if they don't share obvious tags.
Focus on finding non-obvious but meaningful connections."
            :callback (lambda (response info)
                        (if (not response)
                            (message "Search failed: %s" (plist-get info :status))
                          (if (string-empty-p (string-trim response))
                              (message "LLM returned empty response")
                            (with-current-buffer (get-buffer-create "*Related Notes*")
                              (erase-buffer)
                              (insert "* Notes Related to: " current-title "\n\n" response)
                              (org-mode)
                              (goto-char (point-min))
                              (pop-to-buffer (current-buffer)))))))))
    (error (message "Find related notes error: %s" (error-message-string err)))))

(defun bmg/generate-weekly-review ()
  "Generate AI-powered weekly review of knowledge base activity.
Summarizes notes modified this week, identifies themes, suggests connections."
  (interactive)
  (require 'org-roam)
  (let* ((week-ago (time-subtract (current-time) (days-to-time 7)))
         (recent-files '())
         (summaries ""))
    ;; Find recently modified org-roam files
    (dolist (file (org-roam-list-files))
      (when (time-less-p week-ago (file-attribute-modification-time (file-attributes file)))
        (push file recent-files)))
    (if (null recent-files)
        (message "No notes modified in the past week")
      ;; Build summary of each file
      (dolist (file (seq-take recent-files 15))
        (with-temp-buffer
          (insert-file-contents file nil 0 1500)
          (setq summaries (concat summaries
                                  "\n\n--- " (file-name-nondirectory file) " ---\n"
                                  (buffer-string)))))
      (message "Generating weekly review for %d notes..." (length recent-files))
      (gptel-request summaries
        :system "Generate a weekly review of knowledge base activity. Based on the notes modified this week:

1. **Activity Summary** - What areas received attention this week?
2. **Key Themes** - What patterns or topics emerge across the notes?
3. **Notable Insights** - Any interesting ideas or connections worth highlighting?
4. **Suggested Connections** - Notes that might benefit from being linked together
5. **Gaps Identified** - Areas that might need more exploration
6. **Recommended Focus** - Suggestions for next week's focus

Use org-mode formatting. Be concise but insightful."
        :callback (lambda (response info)
                    (if (not response)
                        (message "Review generation failed: %s" (plist-get info :status))
                      (with-current-buffer (get-buffer-create "*Weekly Review*")
                        (erase-buffer)
                        (insert (format "#+title: Weekly Review %s\n#+filetags: :review:weekly:\n\n"
                                        (format-time-string "%Y-%m-%d")))
                        (insert response)
                        (insert (format "\n\n* Files Modified This Week (%d total)\n"
                                        (length recent-files)))
                        (dolist (f (seq-take recent-files 20))
                          (insert (format "- [[file:%s][%s]]\n" f (file-name-nondirectory f))))
                        (org-mode)
                        (goto-char (point-min))
                        (pop-to-buffer (current-buffer)))))))))

(defun bmg/check-tag-consistency ()
  "Scan org-roam notes and report on tag usage patterns.
Shows tag frequency, potential duplicates, and suggestions."
  (interactive)
  (require 'org-roam)
  (let ((tag-counts (make-hash-table :test 'equal))
        (nodes (org-roam-node-list)))
    ;; Count all tags
    (dolist (node nodes)
      (dolist (tag (org-roam-node-tags node))
        (puthash tag (1+ (gethash tag tag-counts 0)) tag-counts)))
    ;; Build report
    (with-current-buffer (get-buffer-create "*Tag Consistency Report*")
      (erase-buffer)
      (insert "* Tag Consistency Report\n\n")
      (insert (format "Total nodes: %d\n" (length nodes)))
      (insert (format "Unique tags: %d\n\n" (hash-table-count tag-counts)))
      ;; Sort by frequency
      (let ((sorted-tags '()))
        (maphash (lambda (k v) (push (cons k v) sorted-tags)) tag-counts)
        (setq sorted-tags (sort sorted-tags (lambda (a b) (> (cdr a) (cdr b)))))
        (insert "** Tag Frequency\n")
        (dolist (tag-count sorted-tags)
          (insert (format "| %s | %d |\n" (car tag-count) (cdr tag-count))))
        ;; Check for potential duplicates (case variations)
        (insert "\n** Potential Duplicates (case variations)\n")
        (let ((lower-tags (make-hash-table :test 'equal)))
          (dolist (tag-count sorted-tags)
            (let ((lower (downcase (car tag-count))))
              (push (car tag-count) (gethash lower lower-tags))))
          (maphash (lambda (k v)
                     (when (> (length v) 1)
                       (insert (format "- %s\n" (string-join v ", ")))))
                   lower-tags)))
      (org-mode)
      (goto-char (point-min))
      (pop-to-buffer (current-buffer)))))

(defun bmg/find-orphan-notes ()
  "Find org-roam notes with no backlinks or forward links.
These might need attention or could be candidates for archival."
  (interactive)
  (require 'org-roam)
  (let ((orphans '())
        (nodes (org-roam-node-list)))
    (dolist (node nodes)
      (let* ((id (org-roam-node-id node))
             (backlinks (org-roam-backlinks-get node))
             (file (org-roam-node-file node)))
        ;; Check for links in the file
        (with-temp-buffer
          (insert-file-contents file)
          (let ((has-links (re-search-forward "\\[\\[id:" nil t)))
            (when (and (null backlinks) (not has-links))
              (push node orphans))))))
    (with-current-buffer (get-buffer-create "*Orphan Notes*")
      (erase-buffer)
      (insert "* Orphan Notes (no links in or out)\n\n")
      (insert (format "Found %d orphan notes out of %d total\n\n" (length orphans) (length nodes)))
      (dolist (node orphans)
        (insert (format "- [[file:%s][%s]] [%s]\n"
                        (org-roam-node-file node)
                        (org-roam-node-title node)
                        (string-join (org-roam-node-tags node) ", "))))
      (org-mode)
      (goto-char (point-min))
      (pop-to-buffer (current-buffer)))))

;;;
;;;
;;; END_llm
;;;
;;;
#+end_src

* Org
:PROPERTIES:
:ID:       b889f253-3691-41e3-a2ca-7f1c76f10d7d
:END:
#+BEGIN_SRC emacs-lisp
;;;
;;;
;;; BEGIN_ORG
;;;
;;;

(defun bmg/switch-to-agenda ()
  "Switch to org-agenda overview view.
Opens the custom 'o' agenda command configured in
`org-agenda-custom-commands'."
  (interactive)
  (org-agenda nil "o"))

(defun bmg/archive-all-done ()
  "Archive all DONE tasks in the current buffer to the archive file."
  (interactive)
  (let ((count 0))
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq count (1+ count))
       (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
     "/DONE" 'file)
    (message "Archived %d DONE tasks" count)))

;; change `org-directory'. It must be set before org loads!
(setq! org-directory "~/Documents/org/"
       org-archive-location (concat org-directory "/archive.org_archive::datetree/")
       org-id-link-to-org-use-id t
       org-ellipsis " â–¾ "
       org-startup-folded t
       org-src-fontify-natively t
       org-hide-emphasis-markers t
       org-modern-star 'replace)


(setq! org-roam-directory (file-truename (concat org-directory "roam/"))
       org-roam-extract-new-file-path "${slug}.org"
       org-default-notes-file (expand-file-name (format "inbox-%s.org" (system-name)) org-roam-directory)
       org-noter-notes-search-path org-roam-directory)

;; Point Doom's org-capture templates to roam inbox for unified capture
(setq! +org-capture-todo-file org-default-notes-file
       +org-capture-notes-file org-default-notes-file)

;; org-protocol for browser integration (Chrome/Firefox capture)
;; Requires desktop file handler configured in NixOS/home-manager
;; Deferred to after org loads to improve startup time

;; Add org-protocol capture templates for web capture
;; "w" - Web page capture (link + optional selection)
;; "W" - Web page capture with immediate finish (quick bookmark)
(with-eval-after-load 'org
  (require 'org-protocol)
  (setq! org-protocol-default-template-key "w")
  (add-to-list 'org-capture-templates
               '("w" "Web Capture" entry
                 (file+headline org-default-notes-file "Inbox")
                 "* %?[[%:link][%:description]] :REFILE:web:\n:PROPERTIES:\n:CREATED: %U\n:SOURCE: %:link\n:END:\n%i"
                 :prepend t))
  (add-to-list 'org-capture-templates
               '("W" "Web Capture (quick)" entry
                 (file+headline org-default-notes-file "Inbox")
                 "* [[%:link][%:description]] :REFILE:web:\n:PROPERTIES:\n:CREATED: %U\n:SOURCE: %:link\n:END:\n%i"
                 :prepend t
                 :immediate-finish t)))

;; Org-roam capture templates
;; Uses subdirectories for organization + filetags for filtering
;; :mkdir t ensures directories are created on first use (multi-machine support)
(setq! org-roam-capture-templates
       '(;; Default note - flat in roam directory
         ("d" "default" plain "%?"
          :if-new (file+head "${slug}.org"
                   "#+title: ${title}\n#+created: %u\n#+last_modified: %U\n#+filetags:\n\n")
          :unnarrowed t)

         ;; Fleeting/quick note - appends to inbox with REFILE tag for GTD processing
         ("f" "fleeting" entry
          (file+headline org-default-notes-file "Inbox")
          "* %? :REFILE:\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i"
          :prepend t)

         ;; Literature/reference note
         ("r" "reference" plain "%?"
          :if-new (file+head "refs/${slug}.org"
                   "#+title: ${title}\n#+created: %u\n#+roam_refs: ${ref}\n#+filetags: :reference:\n\n* Summary\n\n* Notes\n%?")
          :unnarrowed t
          :mkdir t)

         ;; Meeting note
         ("m" "meeting" plain "%?"
          :if-new (file+head "meetings/%<%Y%m%d>-${slug}.org"
                   "#+title: ${title}\n#+date: %<%Y-%m-%d>\n#+created: %u\n#+filetags: :meeting:\n\n* Attendees\n\n* Agenda\n\n* Notes\n%?\n\n* Action Items\n")
          :unnarrowed t
          :mkdir t)))

;; Org-roam dailies configuration
;; Ensure daily notes directory exists
(setq! org-roam-dailies-directory "daily/")
(with-eval-after-load 'org-roam-dailies
  (make-directory (expand-file-name org-roam-dailies-directory org-roam-directory) t))

(setq! org-roam-dailies-capture-templates
       '(("d" "default" entry
          "* %?"
          :target (file+head "%<%Y-%m-%d>.org"
                   "#+title: %<%Y-%m-%d %A>\n#+created: %u\n#+filetags: :daily:\n\n")
          :mkdir t)
         ("t" "task" entry
          "* TODO %?"
          :target (file+head+olp "%<%Y-%m-%d>.org"
                   "#+title: %<%Y-%m-%d %A>\n#+created: %u\n#+filetags: :daily:\n\n"
                   ("Tasks"))
          :mkdir t)
         ("j" "journal" entry
          "* %<%H:%M> %?"
          :target (file+head+olp "%<%Y-%m-%d>.org"
                   "#+title: %<%Y-%m-%d %A>\n#+created: %u\n#+filetags: :daily:\n\n"
                   ("Journal"))
          :mkdir t)))

;; Per-project capture system
;; Stores project files under roam/projects/{project-name}/ instead of in code repos
;; This keeps org files out of shared repositories while maintaining project organization

(defun bmg/get-project-name ()
  "Get current project name or prompt for one.
Uses projectile if in a project, otherwise offers existing project directories."
  (or (and (fboundp 'projectile-project-p)
           (projectile-project-p)
           (projectile-project-name))
      (completing-read "Project: "
                       (when (file-directory-p (expand-file-name "projects" org-roam-directory))
                         (directory-files
                          (expand-file-name "projects" org-roam-directory)
                          nil "^[^.]")))))

(defun bmg/project-org-file (filename)
  "Return path to FILENAME in current project's org directory.
Creates directory and initializes file with proper headers if needed."
  (let* ((project (bmg/get-project-name))
         (dir (expand-file-name (concat "projects/" project) org-roam-directory))
         (file (expand-file-name filename dir)))
    (unless (file-directory-p dir)
      (make-directory dir t))
    ;; Initialize file with proper headers if it doesn't exist
    (unless (file-exists-p file)
      (with-temp-file file
        (pcase filename
          ("todo.org"
           (insert (format "#+title: %s Tasks\n#+created: %s\n#+filetags: :project:todo:\n\n* Inbox\n\n* Active\n\n* Completed\n"
                           project (format-time-string "[%Y-%m-%d %a]"))))
          ("notes.org"
           (insert (format "#+title: %s Notes\n#+created: %s\n#+filetags: :project:notes:\n\n* Inbox\n\n* Notes\n"
                           project (format-time-string "[%Y-%m-%d %a]"))))
          ("changelog.org"
           (insert (format "#+title: %s Changelog\n#+created: %s\n#+filetags: :project:changelog:\n\n* Unreleased\n\n"
                           project (format-time-string "[%Y-%m-%d %a]"))))
          (_
           (insert (format "#+title: %s - %s\n#+created: %s\n#+filetags: :project:\n\n"
                           project (file-name-sans-extension filename)
                           (format-time-string "[%Y-%m-%d %a]")))))))
    file))

(defun bmg/capture-project-todo ()
  "Capture a TODO for the current project.
Adds to Inbox heading with REFILE tag for GTD processing."
  (interactive)
  (let ((file (bmg/project-org-file "todo.org")))
    (find-file file)
    (goto-char (point-min))
    (re-search-forward "^\\* Inbox" nil t)
    (org-end-of-subtree)
    (insert "\n** TODO  :REFILE:")
    (backward-char 8)))

(defun bmg/capture-project-note ()
  "Capture a note for the current project.
Adds to Inbox heading with REFILE tag for GTD processing."
  (interactive)
  (let ((file (bmg/project-org-file "notes.org")))
    (find-file file)
    (goto-char (point-min))
    (re-search-forward "^\\* Inbox" nil t)
    (org-end-of-subtree)
    (insert (format "\n** %s  :REFILE:" (format-time-string "[%Y-%m-%d %a]")))
    (backward-char 9)))

(defun bmg/capture-project-roam-note ()
  "Capture a roam note for the current project.
Creates a new org-roam node in projects/{project-name}/ directory."
  (interactive)
  (let* ((project (bmg/get-project-name))
         (org-roam-capture-templates
          `(("p" "project note" plain "%?"
             :if-new (file+head
                      ,(format "projects/%s/${slug}.org" project)
                      ,(format "#+title: ${title}\n#+created: %%u\n#+filetags: :project:%s:\n\n" project))
             :unnarrowed t
             :mkdir t))))
    (org-roam-capture nil "p")))

(defun bmg/open-project-todo ()
  "Open the TODO file for the current project."
  (interactive)
  (find-file (bmg/project-org-file "todo.org")))

(defun bmg/open-project-notes ()
  "Open the notes file for the current project."
  (interactive)
  (find-file (bmg/project-org-file "notes.org")))

;; Override Doom's project capture functions to use roam/projects/ instead of project-root
;; This makes C-c n n â†’ p â†’ t/n/c use our roam directory
(defadvice! bmg/org-capture-project-todo-file-a ()
  "Override to use roam/projects/{project}/todo.org instead of project-root."
  :override #'+org-capture-project-todo-file
  (bmg/project-org-file "todo.org"))

(defadvice! bmg/org-capture-project-notes-file-a ()
  "Override to use roam/projects/{project}/notes.org instead of project-root."
  :override #'+org-capture-project-notes-file
  (bmg/project-org-file "notes.org"))

(defadvice! bmg/org-capture-project-changelog-file-a ()
  "Override to use roam/projects/{project}/changelog.org instead of project-root."
  :override #'+org-capture-project-changelog-file
  (bmg/project-org-file "changelog.org"))

;; org-mem https://github.com/meedstrom/org-mem is a complimentary package to org roam
;; can use it ot extract certain properties of the roam db. In addition it also provides fast search functionality,
;; such as the ability to populate the org aganda file list with only relevant TODO items
(use-package org-mem
  :after org
  :config
  (setq! org-mem-watch-dirs (list org-roam-directory)
         ;;org-mem-do-sync-with-org-id t
         org-roam-db-update-on-save nil
         org-mem-roamy-do-overwrite-real-db t
         ;; Reduce GC during org-roam operations
         org-roam-db-gc-threshold most-positive-fixnum)

  (defun my-set-agenda-files (&rest _)
    (setq! org-agenda-files
           (cl-loop
            for file in (org-mem-all-files)
            unless (string-search "archive" file)
            when (seq-find (lambda (entry)
                             (or (org-mem-entry-active-timestamps entry)
                                 (org-mem-entry-todo-state entry)
                                 (org-mem-entry-scheduled entry)
                                 (org-mem-entry-deadline entry)))
                           (org-mem-entries-in file))
            collect file)))
  (add-hook 'org-mem-post-full-scan-functions #'my-set-agenda-files)
  (org-mem-roamy-db-mode))

(setq! org-log-done 'time
       org-log-into-drawer t
       org-log-state-notes-insert-after-drawers nil)

(use-package websocket
  :after org-roam)

(use-package org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode org-roam-ui-open)
  :config
  (setq! org-roam-ui-sync-theme t
         org-roam-ui-follow t
         org-roam-ui-update-on-save t
         org-roam-ui-open-on-start nil))

;; citations and reference managment
(setq! citar-bibliography (concat org-directory "emacs_lit.bib")
       citar-library-paths '("~/Documents/Papers/")
       citar-notes-paths org-roam-directory)

(with-eval-after-load 'citar
  ;; define the keymap to allow citar to hand over to biblio to do
  ;; a reference lookup
  (defvar bmg/my-citar-embark-become-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "f") 'citar-open-library-files)
      (define-key map (kbd "x") 'biblio-arxiv-lookup)
      (define-key map (kbd "c") 'biblio-crossref-lookup)
      (define-key map (kbd "i") 'biblio-ieee-lookup)
      (define-key map (kbd "h") 'biblio-hal-lookup)
      (define-key map (kbd "s") 'biblio-dissemin-lookup)
      (define-key map (kbd "b") 'biblio-dblp-lookup)
      (define-key map (kbd "o") 'biblio-doi-insert-bibtex)
      map)
    "Citar Embark become keymap for biblio lookup."))

;; tell embark about the citar keymap after embark loads
(with-eval-after-load 'embark
  (add-to-list 'embark-become-keymaps 'bmg/my-citar-embark-become-map))


(setq! org-tag-alist '((:startgroup . nil)
                       ("@Project" . ?p)
                       ("@Reading" . ?r)
                       ("@Someday" . ?s)
                       ("@Training" . ?t)
                       ("@Courses" . ?c)
                       ("uni" . ?u)
                       ("@Research" . ?R)
                       ("Emacs" . ?e)
                       ("@Issue" . ?i)
                       ("Important" . ?I)
                       (:endgroup . nil)
                       (:startgroup . nil)
                       ("PERSONAL" . ?P)
                       (:endgroup . nil)))

(use-package org-super-agenda
  :after org-agenda
  :init
  (setq!
   ;; more structured view
   org-agenda-prefix-format
   '((agenda . " %i %-20:c %?-12t %12s")
     (todo . " %i %-20:c ")
     (tags . " %i %-20:c ")
     (search . " %i %-20:c "))
   org-agenda-todo-keyword-format "%-6s"
   org-agenda-tags-column -120)

  (setq! org-agenda-time-grid '((daily today require-timed)
                                (800 1200 1600 2000)
                                "......"
                                "----------------")
         org-agenda-skip-scheduled-if-done t
         org-agenda-skip-deadline-if-done t
         org-agenda-include-deadlines t
         org-agenda-include-diary nil
         org-agenda-block-separator nil
         org-agenda-compact-blocks t
         org-agenda-start-with-log-mode t
         org-agenda-span 1
         org-agenda-start-day nil) ;; i.e. today

  ;; Custom agenda view aligned with Doom's org-todo-keywords
  ;; GTD workflow: Inbox/REFILE items appear at top for processing
  (setq! org-agenda-custom-commands
         '(("o" "Overview"
            ((agenda "" ((org-agenda-span 'week)
                         (org-agenda-start-on-weekday 0) ;; Sunday
                         (org-super-agenda-groups
                          '((:name "Today"
                             :time-grid t
                             :date today
                             :todo "TODAY"
                             :scheduled today
                             :order 1)))))
             (alltodo "" ((org-agenda-overriding-header "")
                          (org-super-agenda-groups
                           '((:name "ðŸ“¥ Inbox - Process these first"
                              :tag "REFILE"
                              :order 0)
                             (:name "Next to do"
                              :todo "TODO"
                              :order 3)
                             (:name "Ongoing"
                              :todo "STRT"
                              :order 3)
                             (:name "Recurring"
                              :todo "LOOP"
                              :order 4)
                             (:name "Personal"
                              :tag "PERSONAL"
                              :order 12)
                             (:name "Important"
                              :tag "Important"
                              :priority "A"
                              :order 6)
                             (:name "Due Today"
                              :deadline today
                              :order 2)
                             (:name "Due Soon"
                              :deadline future
                              :order 8)
                             (:name "Overdue"
                              :deadline past
                              :face error
                              :order 7)
                             (:name "Issues"
                              :tag "@Issue"
                              :order 12)
                             (:name "Emacs"
                              :tag "Emacs"
                              :order 13)
                             (:name "Projects"
                              :todo "PROJ"
                              :tag "@Project"
                              :order 14)
                             (:name "Research"
                              :tag "@Research"
                              :order 15)
                              (:name "Training/Courses"
                              :tag ("@Training" "@Courses")
                              :order 16)
                             (:name "To read"
                              :tag "@Reading"
                              :order 30)
                             (:name "Waiting"
                              :todo "HOLD"
                              :todo "WAIT"
                              :order 20)
                             (:name "University"
                              :tag "uni"
                              :order 32)
                             (:name "Someday"
                              :priority<= "C"
                              :tag "@Someday"
                              :todo "IDEA"
                              :order 90)
                             (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
  :config
  (org-super-agenda-mode))

;; Helper functions for org workflow

(defun bmg/org-roam-review-week ()
  "Open all daily notes from the past week for review."
  (interactive)
  (require 'org-roam-dailies)
  (let ((files '()))
    (dotimes (i 7)
      (let* ((date (time-subtract (current-time) (days-to-time i)))
             (file (org-roam-dailies--daily-note-path date)))
        (when (file-exists-p file)
          (push file files))))
    (if files
        (progn
          (dolist (file (reverse files))
            (find-file-other-window file))
          (message "Opened %d daily notes from the past week" (length files)))
      (message "No daily notes found for the past week"))))

;;;
;;;
;;; END_ORG
;;;
;;;
#+END_SRC

* Map
:PROPERTIES:
:ID:       629b4ae3-039b-4729-b3f6-1ae18ed50d13
:END:
#+BEGIN_SRC emacs-lisp
;;;
;;;
;;; BEGIN_Map
;;;
;;;

;; consult-org-roam for enhanced search with live preview
(use-package consult-org-roam
  :after org-roam
  :config
  (consult-org-roam-mode 1)
  (setq consult-org-roam-grep-func #'consult-ripgrep))

;; SPC z for org-roam - shorter than Doom's M-SPC m m / C-c l m
;; Uses consult-org-roam for enhanced find/search with live preview
(with-eval-after-load 'org-roam
  (map! :leader
        (:prefix-map ("z" . "org-roam")
         "c" #'org-roam-capture
         "D" #'org-roam-demote-entire-buffer
         "f" #'consult-org-roam-file-find      ; Enhanced with preview
         "F" #'org-roam-ref-find
         "g" #'org-roam-graph
         "i" #'org-roam-node-insert
         "I" #'org-id-get-create
         "t" #'org-roam-buffer-toggle
         "T" #'org-roam-buffer-display-dedicated
         "r" #'org-roam-refile
         "R" #'bmg/find-related-notes          ; AI: Find related notes
         "s" #'consult-org-roam-search         ; Full-text search
         "S" #'bmg/suggest-tags-for-buffer     ; AI: Suggest tags
         "b" #'consult-org-roam-backlinks      ; Interactive backlinks
         "l" #'consult-org-roam-forward-links  ; Forward links
         "w" #'bmg/generate-weekly-review      ; AI: Weekly review
         (:prefix ("a" . "AI/analysis")
          :desc "Suggest tags"        "t" #'bmg/suggest-tags-for-buffer
          :desc "Summarize paper"     "s" #'bmg/summarize-paper
          :desc "Find related"        "r" #'bmg/find-related-notes
          :desc "Weekly review"       "w" #'bmg/generate-weekly-review
          :desc "Check tags"          "c" #'bmg/check-tag-consistency
          :desc "Find orphans"        "o" #'bmg/find-orphan-notes)
         (:prefix ("d" . "dailies")
          "b" #'org-roam-dailies-goto-previous-note
          "d" #'org-roam-dailies-goto-date
          "D" #'org-roam-dailies-capture-date
          "f" #'org-roam-dailies-goto-next-note
          "m" #'org-roam-dailies-goto-tomorrow
          "M" #'org-roam-dailies-capture-tomorrow
          "n" #'org-roam-dailies-capture-today
          "t" #'org-roam-dailies-goto-today
          "T" #'org-roam-dailies-capture-today
          "y" #'org-roam-dailies-goto-yesterday
          "Y" #'org-roam-dailies-capture-yesterday
          "-" #'org-roam-dailies-find-directory)
         (:prefix ("o" . "node properties")
          "a" #'org-roam-alias-add
          "A" #'org-roam-alias-remove
          "t" #'org-roam-tag-add
          "T" #'org-roam-tag-remove
          "r" #'org-roam-ref-add
          "R" #'org-roam-ref-remove)
         (:prefix ("p" . "project")
          :desc "Project todo"      "t" #'bmg/capture-project-todo
          :desc "Project note"      "n" #'bmg/capture-project-note
          :desc "Project roam note" "p" #'bmg/capture-project-roam-note
          :desc "Open project todo" "T" #'bmg/open-project-todo
          :desc "Open project notes" "N" #'bmg/open-project-notes)
         (:prefix ("u" . "UI")
          :desc "Open graph"        "u" #'org-roam-ui-open
          :desc "Toggle UI mode"    "m" #'org-roam-ui-mode))))

(map!
 (;;: org-agenda
  (:leader
        ;;; <leader> n --- notes
   (:prefix ("n" . "notes")
    :desc "Org agenda"  "a" #'bmg/switch-to-agenda))

  (:map org-agenda-mode-map
        "i"                       #'org-agenda-clock-in
        "R"                       #'org-agenda-refile))

 (;;: open submenu
  (:leader
        ;;; <leader> o --- open
   (:prefix ("o" . "open")
    :desc "Url"  "u" #'browse-url
    :desc "Web"  "w" #'browse-url)))

 (;;: crux and stuff
  (:leader
        ;;;  <leader> b --- prelude
   (:prefix-map ("b" . "prelude")
    :desc "crux-cleanup-buffer-or-region"          "c" #'crux-cleanup-buffer-or-region
    :desc "crux-duplicate-current-line-or-region"  "d" #'crux-duplicate-current-line-or-region
    :desc "crux-delete-file-and-buffer"            "D" #'crux-delete-file-and-buffer
    :desc "crux-kill-other-buffers"                "k" #'crux-kill-other-buffers
    :desc "crux-open-with"                         "o" #'crux-open-with
    :desc "crux-rename-buffer-and-file"            "r" #'crux-rename-buffer-and-file
    :desc "crux-transpose-windows"                 "s" #'crux-transpose-windows
    :desc "crux-view-url"                          "u" #'crux-view-url
    :desc "crux-indent-defun"                      "TAB" #'crux-indent-defun
    :desc "Elfeed RSS enter"                       "e" #'=rss))

  (:leader
   (:prefix ("s" . "search")
    :desc "Search papers (rga)"                    "P" #'bmg/rga-search
    :desc "Ask knowledge base"                     "Q" #'bmg/ask-knowledge-base
    :desc "Search knowledge base"                  "k" #'bmg/search-knowledge-base)))
 ) ;; END MAP

;; Localleader bindings for org-mode AI functions (C-c l in org-mode)
(with-eval-after-load 'org
  (map! :map org-mode-map
        :localleader
        :desc "Process inbox item" "P" #'bmg/process-inbox-item
        :desc "Summarize paper"    "S" #'bmg/summarize-paper))

;; Standard Emacs C-c prefix keybindings for AI functions
;; C-c a = AI knowledge management prefix
(defvar bmg/ai-command-map
  (let ((map (make-sparse-keymap)))
    ;; Tag and summarization
    (define-key map (kbd "t") #'bmg/suggest-tags-for-buffer)
    (define-key map (kbd "s") #'bmg/summarize-paper)
    (define-key map (kbd "p") #'bmg/process-inbox-item)
    ;; Discovery and search
    (define-key map (kbd "r") #'bmg/find-related-notes)
    (define-key map (kbd "q") #'bmg/ask-knowledge-base)
    (define-key map (kbd "k") #'bmg/search-knowledge-base)
    ;; Review and maintenance
    (define-key map (kbd "w") #'bmg/generate-weekly-review)
    (define-key map (kbd "c") #'bmg/check-tag-consistency)
    (define-key map (kbd "o") #'bmg/find-orphan-notes)
    map)
  "Keymap for AI-powered knowledge management commands.")

(global-set-key (kbd "C-c a") bmg/ai-command-map)

;; ripgrep-all for searching PDFs and documents
(defun bmg/rga-search (query)
  "Search PDFs and documents in Papers directory with ripgrep-all."
  (interactive "sSearch papers: ")
  (let ((default-directory "~/Documents/Papers/"))
    (compilation-start
     (format "rga --color=never --heading --line-number %s"
             (shell-quote-argument query))
     'grep-mode
     (lambda (_) "*rga-search*"))))

(defun bmg/search-knowledge-base (query)
  "Search across org-roam notes, PDFs, and bibliography.
Presents results in a unified interface."
  (interactive "sSearch: ")
  (let ((results-buffer (get-buffer-create "*Knowledge Base Search*")))
    (with-current-buffer results-buffer
      (erase-buffer)
      (insert (format "* Knowledge Base Search: %s\n\n" query))

      ;; 1. Org-roam notes search
      (insert "** Org-roam Notes\n")
      (let ((default-directory org-roam-directory))
        (insert (shell-command-to-string
                 (format "rg --color=never -l -i %s --type org 2>/dev/null | head -20"
                         (shell-quote-argument query)))))
      (insert "\n")

      ;; 2. PDF content search
      (insert "** Papers (PDF content)\n")
      (let ((default-directory "~/Documents/Papers/"))
        (insert (shell-command-to-string
                 (format "rga --color=never --files-with-matches %s 2>/dev/null | head -15"
                         (shell-quote-argument query)))))
      (insert "\n")

      ;; 3. Bibliography search
      (insert "** Bibliography\n")
      (insert (shell-command-to-string
               (format "rg --color=never -i %s %s 2>/dev/null | head -20"
                       (shell-quote-argument query)
                       (shell-quote-argument (expand-file-name citar-bibliography)))))

      (org-mode)
      (goto-char (point-min)))
    (pop-to-buffer results-buffer)))

(map! :map dirvish-mode-map
      ;; left click for expand/collapse dir or open file
      "<mouse-1>" #'dirvish-subtree-toggle-or-open
      ;; middle click for opening file / entering dir in other window
      "<mouse-2>" #'dired-mouse-find-file-other-window
      ;; right click for opening file / entering dir
      "<mouse-3>" #'dired-mouse-find-file
      "?"   #'dirvish-dispatch
      "q"   #'dirvish-quit
      "b"   #'dirvish-quick-access
      "f"   #'dirvish-file-info-menu
      "p"   #'dirvish-yank
      "S"   #'dirvish-quicksort
      "F"   #'dirvish-layout-toggle
      "z"   #'dirvish-history-jump
      "TAB" #'dirvish-subtree-toggle
      "M-b" #'dirvish-history-go-backward
      "M-f" #'dirvish-history-go-forward
      "M-n" #'dirvish-narrow
      "M-m" #'dirvish-mark-menu
      "M-s" #'dirvish-setup-menu
      "M-e" #'dirvish-emerge-menu
      (:prefix ("y" . "yank")
               "l"   #'dirvish-copy-file-true-path
               "n"   #'dirvish-copy-file-name
               "p"   #'dirvish-copy-file-path
               "r"   #'dirvish-copy-remote-path
               "y"   #'dired-do-copy)
      (:prefix ("s" . "symlinks")
               "s"   #'dirvish-symlink
               "S"   #'dirvish-relative-symlink
               "h"   #'dirvish-hardlink))

;;;
;;;
;;; END_MAP
;;;
;;;
#+END_SRC

* Elfeed Enhancements
#+BEGIN_SRC emacs-lisp
;;;
;;;
;;; BEGIN_Elfeed_Enhancements
;;;
;;;

(defun bmg/elfeed-mark-all-as-read ()
  "Mark all entries in current elfeed filter as read."
  (interactive)
  (when (yes-or-no-p "Mark all visible entries as read? ")
    (let ((count 0))
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (when-let ((entry (elfeed-search-selected :ignore-region)))
            (elfeed-untag entry 'unread)
            (setq count (1+ count)))
          (forward-line)))
      (elfeed-search-update--force)
      (message "Marked %d entries as read" count))))

(defun bmg/elfeed-capture-arxiv ()
  "Capture current elfeed arxiv entry to org-roam reference note."
  (interactive)
  (unless (bound-and-true-p elfeed-show-entry)
    (user-error "Not in an elfeed entry buffer"))
  (let* ((entry elfeed-show-entry)
         (title (elfeed-entry-title entry))
         (link (elfeed-entry-link entry))
         (authors (or (elfeed-meta entry :authors) "Unknown"))
         (authors-str (if (listp authors)
                          (mapconcat (lambda (a) (or (plist-get a :name) "")) authors ", ")
                        authors))
         (abstract (elfeed-deref (elfeed-entry-content entry))))
    (org-roam-capture-
     :node (org-roam-node-create :title title)
     :templates
     `(("a" "arxiv paper" plain
        ,(concat "- Source :: " link "\n"
                 "- Authors :: " authors-str "\n\n"
                 "* Abstract\n\n"
                 (or abstract "") "\n\n"
                 "* Notes\n\n%?")
        :target (file+head "roam/${slug}.org"
                           ,(concat ":PROPERTIES:\n"
                                    ":ID: %(org-id-new)\n"
                                    ":END:\n"
                                    "#+title: ${title}\n"
                                    "#+filetags: :arxiv:paper:\n\n"))
        :unnarrowed t)))))

(with-eval-after-load 'elfeed
  (map! :map elfeed-search-mode-map
        "R" #'bmg/elfeed-mark-all-as-read)
  (map! :map elfeed-show-mode-map
        "C" #'bmg/elfeed-capture-arxiv))

;;;
;;;
;;; END_Elfeed_Enhancements
;;;
;;;
#+END_SRC

* reMarkable Integration
:PROPERTIES:
:ID:       remarkable-integration
:END:

Integration between reMarkable Paper Pro tablet and Emacs org-mode.
Uses USB Web Interface (http://10.11.99.1) - NO developer mode required!

Setup:
1. On reMarkable: Settings â†’ Storage â†’ Enable "USB web interface"
2. Connect device via USB cable
3. Test: =C-c r t= (remarkable-test-connection)

** Core Configuration
#+BEGIN_SRC emacs-lisp
;;; reMarkable Integration -*- lexical-binding: t; -*-

;; Declare external variables to avoid byte-compile warnings
(defvar org-directory)
(defvar org-roam-directory)
(defvar citar-library-paths)
(defvar org-latex-classes)
(defvar org-latex-default-class)

;; Declare external functions
(declare-function org-roam-node-at-point "org-roam-node")
(declare-function org-roam-node-title "org-roam-node")
(declare-function org-roam-node-slug "org-roam-node")
(declare-function org-roam-node-read "org-roam-node")
(declare-function org-roam-node-file "org-roam-node")
(declare-function org-roam-db-update-file "org-roam-db")
(declare-function org-roam-dailies-goto-today "org-roam-dailies")
(declare-function org-latex-export-to-pdf "ox-latex")
(declare-function org-get-heading "org")
(declare-function org-narrow-to-subtree "org")
(declare-function org-noter "org-noter")

(defgroup remarkable nil
  "reMarkable tablet integration via USB web interface."
  :group 'tools
  :prefix "remarkable-")

(defcustom remarkable-url "http://10.11.99.1"
  "USB web interface URL for reMarkable tablet."
  :type 'string
  :group 'remarkable)

(defcustom remarkable-local-dir
  (expand-file-name "remarkable" org-directory)
  "Local directory for reMarkable sync."
  :type 'directory
  :group 'remarkable)

(defcustom remarkable-papers-dir
  (car citar-library-paths)
  "Directory for academic papers."
  :type 'directory
  :group 'remarkable)

(defcustom remarkable-epub-dir
  (expand-file-name "~/Documents/EPUB")
  "Directory for ebooks."
  :type 'directory
  :group 'remarkable)

;; Defer directory creation until first use (avoid startup I/O)
(defun remarkable--ensure-directories ()
  "Ensure remarkable directories exist. Called lazily on first use."
  (dolist (subdir '("downloads" "outbox" "notes"))
    (make-directory (expand-file-name subdir remarkable-local-dir) t)))

#+END_SRC

** USB Web Interface Functions
#+BEGIN_SRC emacs-lisp
(defun remarkable--api-request (endpoint &optional method)
  "Make HTTP request to reMarkable USB web interface ENDPOINT.
METHOD defaults to GET."
  (let ((url (concat remarkable-url endpoint)))
    (with-temp-buffer
      (if (zerop (call-process "curl" nil t nil
                               "--silent" "--connect-timeout" "3"
                               (or method "--request" "GET")
                               url))
          (buffer-string)
        nil))))

(defun remarkable--device-connected-p ()
  "Check if reMarkable is connected via USB."
  (remarkable--api-request "/documents/"))

(defun remarkable--get-documents (&optional parent-id)
  "Get documents list from reMarkable, optionally from PARENT-ID folder."
  (let* ((endpoint (if parent-id
                       (format "/documents/%s" parent-id)
                     "/documents/"))
         (response (remarkable--api-request endpoint)))
    (when response
      (json-read-from-string response))))

(defun remarkable--download-document (uuid output-file)
  "Download document UUID as PDF to OUTPUT-FILE."
  (let ((url (format "%s/download/%s/pdf" remarkable-url uuid)))
    (zerop (call-process "curl" nil nil nil
                         "--silent" "--fail"
                         "-o" output-file
                         url))))

(defun remarkable--upload-file (file)
  "Upload FILE to reMarkable via USB web interface."
  (let* ((filename (file-name-nondirectory file))
         (content-type (if (string-suffix-p ".epub" filename t)
                           "application/epub+zip"
                         "application/pdf")))
    ;; First list root to set upload destination
    (remarkable--api-request "/documents/")
    ;; Upload file
    (zerop (call-process "curl" nil nil nil
                         "--silent" "--fail"
                         "-H" (format "Origin: %s" remarkable-url)
                         "-H" "Accept: */*"
                         "-H" (format "Referer: %s/" remarkable-url)
                         "-F" (format "file=@%s;filename=%s;type=%s"
                                      file filename content-type)
                         (concat remarkable-url "/upload")))))

#+END_SRC

** Sync Functions
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun remarkable-test-connection ()
  "Test connection to reMarkable USB web interface."
  (interactive)
  (if (remarkable--device-connected-p)
      (message "âœ“ reMarkable is connected via USB at %s" remarkable-url)
    (message "âœ— Cannot reach reMarkable. Ensure USB is connected and web interface enabled.")))

;;;###autoload
(defun remarkable-sync-from-device ()
  "Download all documents from reMarkable (with annotations pre-rendered)."
  (interactive)
  (unless (remarkable--device-connected-p)
    (user-error "reMarkable not connected. Connect via USB and enable web interface"))
  (remarkable--ensure-directories)
  (let ((downloads-dir (expand-file-name "downloads" remarkable-local-dir))
        (documents (remarkable--get-documents))
        (count 0))
    (make-directory downloads-dir t)
    (dolist (doc (append documents nil))
      (let* ((type (alist-get 'Type doc))
             (id (alist-get 'ID doc))
             (name (alist-get 'VissibleName doc)))
        (cond
         ;; Document - download it
         ((string= type "DocumentType")
          (let ((output-file (expand-file-name (concat name ".pdf") downloads-dir)))
            (unless (file-exists-p output-file)
              (message "Downloading: %s..." name)
              (when (remarkable--download-document id output-file)
                (setq count (1+ count))))))
         ;; Folder - recurse into it
         ((string= type "CollectionType")
          (let ((folder-dir (expand-file-name name downloads-dir))
                (folder-docs (remarkable--get-documents id)))
            (make-directory folder-dir t)
            (dolist (subdoc (append folder-docs nil))
              (when (string= (alist-get 'Type subdoc) "DocumentType")
                (let* ((subid (alist-get 'ID subdoc))
                       (subname (alist-get 'VissibleName subdoc))
                       (output-file (expand-file-name (concat subname ".pdf") folder-dir)))
                  (unless (file-exists-p output-file)
                    (message "Downloading: %s/%s..." name subname)
                    (when (remarkable--download-document subid output-file)
                      (setq count (1+ count))))))))))))
    (message "Downloaded %d new documents to %s" count downloads-dir)))

;;;###autoload
(defun remarkable-sync-to-device ()
  "Upload PDFs/EPUBs from outbox to reMarkable via USB web interface."
  (interactive)
  (unless (remarkable--device-connected-p)
    (user-error "reMarkable not connected. Connect via USB and enable web interface"))
  (remarkable--ensure-directories)
  (let* ((outbox (expand-file-name "outbox" remarkable-local-dir))
         (files (directory-files outbox t "\\.\\(pdf\\|epub\\)$" t))
         (processed-dir (expand-file-name ".processed" outbox))
         (count 0))
    (if (null files)
        (message "No PDFs or EPUBs in outbox to upload")
      (make-directory processed-dir t)
      (dolist (file files)
        (message "Uploading: %s..." (file-name-nondirectory file))
        (if (remarkable--upload-file file)
            (progn
              (rename-file file (expand-file-name (file-name-nondirectory file) processed-dir) t)
              (setq count (1+ count))
              (message "Uploaded: %s" (file-name-nondirectory file)))
          (message "Failed to upload: %s" (file-name-nondirectory file))))
      (message "Uploaded %d files to reMarkable" count))))

;;;###autoload
(defun remarkable-list-documents ()
  "List documents on reMarkable device."
  (interactive)
  (unless (remarkable--device-connected-p)
    (user-error "reMarkable not connected"))
  (let ((documents (remarkable--get-documents))
        (buf (get-buffer-create "*reMarkable Documents*")))
    (with-current-buffer buf
      (erase-buffer)
      (insert "Documents on reMarkable:\n")
      (insert "========================\n\n")
      (dolist (doc (append documents nil))
        (let* ((type (alist-get 'Type doc))
               (id (alist-get 'ID doc))
               (name (alist-get 'VissibleName doc)))
          (if (string= type "CollectionType")
              (progn
                (insert (format "ðŸ“ %s/\n" name))
                (let ((folder-docs (remarkable--get-documents id)))
                  (dolist (subdoc (append folder-docs nil))
                    (insert (format "   ðŸ“„ %s  [%s]\n"
                                    (alist-get 'VissibleName subdoc)
                                    (alist-get 'ID subdoc))))))
            (insert (format "ðŸ“„ %s  [%s]\n" name id))))))
    (pop-to-buffer buf)
    (goto-char (point-min))))

#+END_SRC

** Send Papers/EPUBs to reMarkable
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun remarkable-send-paper ()
  "Send a paper from Papers directory to reMarkable."
  (interactive)
  (remarkable--send-file-to-device remarkable-papers-dir "Paper"))

;;;###autoload
(defun remarkable-send-epub ()
  "Send an EPUB/PDF from EPUB directory to reMarkable."
  (interactive)
  (remarkable--send-file-to-device remarkable-epub-dir "Book"))

(defun remarkable--send-file-to-device (source-dir type-name)
  "Send a file from SOURCE-DIR to reMarkable outbox.
TYPE-NAME is used in prompts (e.g., \"Paper\", \"Book\")."
  (let* ((file (read-file-name (format "%s to send: " type-name) source-dir nil t nil
                               (lambda (f)
                                 (or (string-suffix-p ".pdf" f)
                                     (string-suffix-p ".epub" f)))))
         (outbox (expand-file-name "outbox" remarkable-local-dir))
         (dest (expand-file-name (file-name-nondirectory file) outbox)))
    (make-directory outbox t)
    (copy-file file dest t)
    (message "Copied to outbox: %s" (file-name-nondirectory file))
    (when (y-or-n-p "Upload to reMarkable now? ")
      (remarkable-sync-to-device))))

;;;###autoload
(defun remarkable-send-current-buffer ()
  "Send current PDF or EPUB buffer to reMarkable."
  (interactive)
  (let ((file (buffer-file-name)))
    (unless file
      (user-error "Buffer is not visiting a file"))
    (unless (or (string-suffix-p ".pdf" file)
                (string-suffix-p ".epub" file))
      (user-error "Buffer is not a PDF or EPUB file"))
    (let* ((outbox (expand-file-name "outbox" remarkable-local-dir))
           (dest (expand-file-name (file-name-nondirectory file) outbox)))
      (make-directory outbox t)
      (copy-file file dest t)
      (message "Copied to outbox: %s" (file-name-nondirectory file))
      (when (y-or-n-p "Upload to reMarkable now? ")
        (remarkable-sync-to-device)))))

#+END_SRC

** Export Org-Roam to reMarkable
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun remarkable-export-roam-node ()
  "Export current org-roam node to PDF for reMarkable."
  (interactive)
  (unless (and (featurep 'org-roam) (org-roam-node-at-point))
    (user-error "Not in an org-roam node"))
  (let* ((node (org-roam-node-at-point))
         (title (org-roam-node-title node))
         (slug (org-roam-node-slug node))
         (org-latex-default-class "remarkable")
         (outbox (expand-file-name "outbox" remarkable-local-dir))
         (output-name (format "%s.pdf" slug)))
    (make-directory outbox t)
    (let ((pdf-file (org-latex-export-to-pdf)))
      (when pdf-file
        (rename-file pdf-file (expand-file-name output-name outbox) t)
        (message "Exported '%s' to outbox" title)
        (when (y-or-n-p "Upload to reMarkable now? ")
          (remarkable-sync-to-device))))))

;;;###autoload
(defun remarkable-export-subtree ()
  "Export current org subtree to PDF for reMarkable."
  (interactive)
  (let* ((title (org-get-heading t t t t))
         (slug (replace-regexp-in-string "[^a-zA-Z0-9]" "-" (downcase title)))
         (org-latex-default-class "remarkable")
         (outbox (expand-file-name "outbox" remarkable-local-dir))
         (output-name (format "%s.pdf" slug)))
    (make-directory outbox t)
    (save-restriction
      (org-narrow-to-subtree)
      (let ((pdf-file (org-latex-export-to-pdf)))
        (widen)
        (when pdf-file
          (rename-file pdf-file (expand-file-name output-name outbox) t)
          (message "Exported subtree '%s' to outbox" title)
          (when (y-or-n-p "Upload to reMarkable now? ")
            (remarkable-sync-to-device)))))))

#+END_SRC

** Import Handwritten Notes to Org-Roam
#+BEGIN_SRC emacs-lisp
(defun remarkable--safe-filename (name)
  "Convert NAME to a safe filename."
  (replace-regexp-in-string "[^a-zA-Z0-9_-]" "_" name))

(defun remarkable--list-downloaded-pdfs ()
  "List available PDFs from downloads directory."
  (let ((downloads-dir (expand-file-name "downloads" remarkable-local-dir)))
    (when (file-directory-p downloads-dir)
      (directory-files-recursively downloads-dir "\\.pdf$"))))

;;;###autoload
(defun remarkable-import-handwritten-note ()
  "Import a downloaded PDF note from reMarkable into org-roam."
  (interactive)
  (let* ((pdfs (remarkable--list-downloaded-pdfs)))
    (unless pdfs
      (user-error "No PDFs found. Run remarkable-sync-from-device first"))
    (let* ((choice (completing-read "Select PDF: " pdfs nil t))
           (title (file-name-base choice))
           (notes-dir (expand-file-name "notes" remarkable-local-dir))
           (pdf-dest (expand-file-name (file-name-nondirectory choice) notes-dir))
           (action (completing-read
                    "Action: "
                    '("Create new org-roam node"
                      "Link to existing node"
                      "Add to today's daily note")
                    nil t)))
      ;; Copy to notes directory
      (make-directory notes-dir t)
      (copy-file choice pdf-dest t)
      ;; Handle based on action
      (pcase action
        ("Create new org-roam node"
         (remarkable--create-roam-node-from-handwritten title pdf-dest))
        ("Link to existing node"
         (remarkable--link-to-existing-node title pdf-dest))
        ("Add to today's daily note"
         (remarkable--add-to-daily-note title pdf-dest))))))

(defun remarkable--create-roam-node-from-handwritten (title pdf-file)
  "Create a new org-roam node for handwritten note TITLE linking to PDF-FILE."
  (let* ((slug (remarkable--safe-filename title))
         (org-file (expand-file-name (format "%s.org" slug) org-roam-directory)))
    (find-file org-file)
    (insert (format "#+title: %s
#+created: %s
#+filetags: :remarkable:handwritten:

* Handwritten Notes
:PROPERTIES:
:RM_IMPORTED: %s
:END:

[[file:%s][View handwritten notes (PDF)]]

* Summary / Key Points

" title
   (format-time-string "[%Y-%m-%d %a]")
   (format-time-string "[%Y-%m-%d %a %H:%M]")
   pdf-file))
    (save-buffer)
    (org-roam-db-update-file)
    (message "Created org-roam node: %s" title)))

(defun remarkable--link-to-existing-node (title pdf-file)
  "Link handwritten note PDF-FILE to an existing org-roam node."
  (let ((node (org-roam-node-read)))
    (find-file (org-roam-node-file node))
    (goto-char (point-max))
    (insert (format "
* Handwritten Notes: %s :remarkable:
:PROPERTIES:
:RM_IMPORTED: %s
:END:

[[file:%s][View handwritten notes (PDF)]]

" title (format-time-string "[%Y-%m-%d %a %H:%M]") pdf-file))
    (save-buffer)
    (message "Linked to: %s" (org-roam-node-title node))))

(defun remarkable--add-to-daily-note (title pdf-file)
  "Add handwritten note PDF-FILE to today's org-roam daily note."
  (require 'org-roam-dailies)
  (org-roam-dailies-goto-today)
  (goto-char (point-max))
  (insert (format "
* %s :remarkable:
:PROPERTIES:
:RM_IMPORTED: %s
:END:

[[file:%s][View handwritten notes]]

" title (format-time-string "[%Y-%m-%d %a %H:%M]") pdf-file))
  (save-buffer)
  (message "Added to today's daily note"))

#+END_SRC

** Open Downloaded PDFs
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun remarkable-open-downloaded ()
  "Open a downloaded PDF from reMarkable in Emacs."
  (interactive)
  (let ((files (remarkable--list-downloaded-pdfs)))
    (if (null files)
        (user-error "No downloaded PDFs found.  Run remarkable-sync-from-device first")
      (let ((file (completing-read "PDF: " files nil t)))
        (find-file file)))))

;;;###autoload
(defun remarkable-open-in-noter ()
  "Open a downloaded PDF from reMarkable in org-noter."
  (interactive)
  (remarkable-open-downloaded)
  (org-noter))

;;;###autoload
(defun remarkable-browse-downloads ()
  "Browse downloaded PDFs directory."
  (interactive)
  (let ((downloads-dir (expand-file-name "downloads" remarkable-local-dir)))
    (make-directory downloads-dir t)
    (dired downloads-dir)))

;;;###autoload
(defun remarkable-browse-notes ()
  "Browse notes directory."
  (interactive)
  (let ((notes-dir (expand-file-name "notes" remarkable-local-dir)))
    (make-directory notes-dir t)
    (dired notes-dir)))

#+END_SRC

** LaTeX Class for reMarkable
#+BEGIN_SRC emacs-lisp
;; A5 format optimized for reMarkable's 10.3" screen
(with-eval-after-load 'ox-latex
  (add-to-list 'org-latex-classes
               '("remarkable"
                 "\\documentclass[11pt,a5paper]{article}
\\usepackage[margin=1.2cm]{geometry}
\\usepackage{libertine}
\\usepackage{inconsolata}
\\usepackage{parskip}
\\usepackage[colorlinks=false]{hyperref}
\\setlength{\\parindent}{0pt}
\\pagestyle{plain}
[NO-DEFAULT-PACKAGES]
[PACKAGES]
[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))

#+END_SRC

** Keybindings
Bind to =C-c r= prefix for standard Emacs keybindings (no evil).
#+BEGIN_SRC emacs-lisp
;; Define remarkable keymap for C-c r prefix
(defvar remarkable-command-map
  (let ((map (make-sparse-keymap)))
    ;; Connection
    (define-key map (kbd "t") #'remarkable-test-connection)
    (define-key map (kbd "l") #'remarkable-list-documents)
    ;; Sync
    (define-key map (kbd "s") #'remarkable-sync-from-device)
    (define-key map (kbd "u") #'remarkable-sync-to-device)
    ;; Send content
    (define-key map (kbd "p") #'remarkable-send-paper)
    (define-key map (kbd "b") #'remarkable-send-epub)
    (define-key map (kbd "c") #'remarkable-send-current-buffer)
    ;; Export from Emacs
    (define-key map (kbd "e") #'remarkable-export-roam-node)
    (define-key map (kbd "E") #'remarkable-export-subtree)
    ;; Import to Emacs
    (define-key map (kbd "i") #'remarkable-import-handwritten-note)
    ;; Open/Browse
    (define-key map (kbd "o") #'remarkable-open-downloaded)
    (define-key map (kbd "n") #'remarkable-open-in-noter)
    (define-key map (kbd "d") #'remarkable-browse-downloads)
    (define-key map (kbd "N") #'remarkable-browse-notes)
    map)
  "Keymap for reMarkable commands.")

;; Bind to C-c r prefix
(global-set-key (kbd "C-c r") remarkable-command-map)

;; Also add to Doom's leader if available (works with or without evil)
(when (boundp 'doom-leader-map)
  (define-key doom-leader-map (kbd "r") (cons "reMarkable" remarkable-command-map)))

;;;
;;;
;;; END_REMARKABLE
;;;
;;;
#+END_SRC
